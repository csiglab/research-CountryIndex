<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Zealand Actor Space — Event Representation</title>
    
    <!-- Fonts: Elegant Oxford/Academic Style -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=EB+Garamond:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        :root {
            --bg-primary: #F6F4EF; /* Vellum */
            --bg-secondary: #EDE9E0;
            --fg-primary: #1A1A1A; /* Ink */
            --fg-secondary: #4A4A4A;
            --fg-muted: #78716C;
            --accent-public: #1E3A5F; /* Navy */
            --accent-private: #7F1D1D; /* Burgundy */
            --accent-hybrid: #2D4A3E; /* Forest */
            --border-subtle: #D1CCC0;
            --event-stroke: rgba(26, 26, 26, 0.8);
        }
        
        body {
            font-family: 'EB Garamond', serif;
            background-color: var(--bg-primary);
            color: var(--fg-primary);
        }
        
        .font-display {
            font-family: 'Cormorant Garamond', serif;
        }
        
        /* Canvas specific */
        #viz-canvas {
            cursor: crosshair;
        }
        
        /* Controls */
        .control-panel {
            background: rgba(246, 244, 239, 0.9);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .btn-classic {
            border: 1px solid var(--fg-muted);
            background: transparent;
            transition: all 0.2s ease;
        }
        .btn-classic:hover {
            background: var(--fg-primary);
            color: var(--bg-primary);
            border-color: var(--fg-primary);
        }
        
        /* Tooltip */
        .tooltip-box {
            position: absolute;
            background: #fff;
            border: 1px solid var(--fg-muted);
            padding: 12px 16px;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 100;
            max-width: 300px;
        }
        
        /* Detail Sidebar */
        .detail-sidebar {
            position: fixed;
            right: 0;
            top: 0;
            height: 100vh;
            width: 320px;
            background: var(--bg-primary);
            border-left: 1px solid var(--border-subtle);
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 50;
            overflow-y: auto;
        }
        .detail-sidebar.open {
            transform: translateX(0);
        }

        /* Timeline Axis */
        .time-axis {
            height: 40px;
            border-top: 1px solid var(--fg-muted);
            background: var(--bg-secondary);
        }
        
        /* Animations */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(2); opacity: 0; }
        }
    </style>
</head>
<body class="overflow-hidden">

    <!-- Header -->
    <header class="control-panel py-4 px-6 flex justify-between items-center">
        <div>
            <h1 class="font-display text-2xl font-medium tracking-wide">New Zealand Actor Space</h1>
            <p class="text-xs text-[var(--fg-muted)] uppercase tracking-widest mt-1">Event-Based Temporal Representation, 1800–Present</p>
        </div>
        <div class="flex items-center gap-4 text-sm">
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 rounded-full bg-[var(--accent-public)]"></div>
                <span>Public</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 rounded-full bg-[var(--accent-private)]"></div>
                <span>Private</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 rounded-full bg-[var(--accent-hybrid)]"></div>
                <span>Hybrid</span>
            </div>
        </div>
    </header>

    <!-- Main Visualization -->
    <main class="relative flex flex-col" style="height: calc(100vh - 80px);">
        
        <!-- Filters / Controls -->
        <div class="absolute top-4 left-4 z-20 flex gap-2">
            <button id="btn-zoom-in" class="btn-classic px-3 py-1 text-sm rounded-sm">+</button>
            <button id="btn-zoom-out" class="btn-classic px-3 py-1 text-sm rounded-sm">−</button>
            <button id="btn-reset" class="btn-classic px-3 py-1 text-sm rounded-sm">Reset View</button>
        </div>

        <!-- The Canvas -->
        <div class="flex-1 relative">
            <canvas id="viz-canvas"></canvas>
            
            <!-- Hover Tooltip -->
            <div id="tooltip" class="tooltip-box font-display">
                <div class="text-xs text-[var(--fg-muted)] uppercase tracking-wider" id="tt-type">Event Type</div>
                <div class="text-lg font-medium" id="tt-actor">Actor Name</div>
                <div class="text-sm italic" id="tt-desc">Description</div>
                <div class="mt-2 text-xs font-mono" id="tt-date">Date</div>
            </div>
        </div>

        <!-- Time Axis -->
        <div class="time-axis relative">
            <canvas id="axis-canvas"></canvas>
        </div>
        
    </main>

    <!-- Detail Sidebar (Consolidated Actor View) -->
    <aside id="sidebar" class="detail-sidebar p-6">
        <button id="close-sidebar" class="absolute top-4 right-4 text-sm opacity-50 hover:opacity-100">✕</button>
        <div class="border-b border-[var(--border-subtle)] pb-4 mb-4">
            <h2 class="font-display text-3xl font-medium" id="sb-name">Actor Name</h2>
            <p class="text-sm text-[var(--fg-muted)] uppercase tracking-wider" id="sb-role">Role</p>
        </div>
        
        <div class="space-y-4">
            <div>
                <h3 class="text-xs uppercase tracking-wider text-[var(--fg-muted)] mb-1">Type</h3>
                <p id="sb-type" class="text-sm font-medium">Public</p>
            </div>
            <div>
                <h3 class="text-xs uppercase tracking-wider text-[var(--fg-muted)] mb-1">Region</h3>
                <p id="sb-region" class="text-sm">Region</p>
            </div>
            <div>
                <h3 class="text-xs uppercase tracking-wider text-[var(--fg-muted)] mb-1">Description</h3>
                <p id="sb-desc" class="text-sm italic">Description text...</p>
            </div>
            
            <!-- Consolidated Timeline in Sidebar -->
            <div class="mt-6 pt-4 border-t border-[var(--border-subtle)]">
                <h3 class="text-xs uppercase tracking-wider text-[var(--fg-muted)] mb-4">Consolidated Event Sequence</h3>
                <div id="sb-timeline" class="space-y-4 pl-4 border-l-2 border-[var(--fg-muted)]">
                    <!-- Events will be injected here -->
                </div>
            </div>
        </div>
    </aside>

    <!-- Data Structure (Simulated Data) -->
    <script type="application/json" id="data-json">
    [
        {
            "id": "a1", "name": "New Zealand Company", "type": "private", "role": "Colonization", "region": "Wellington",
            "description": "Private British company instrumental in the early colonization.",
            "events": [
                { "date": "1839-05-02", "type": "birth", "desc": "Established in London" },
                { "date": "1841-01-22", "type": "expansion", "desc": "Wellington settlement founded" },
                { "date": "1858-12-31", "type": "death", "desc": "Dissolution" }
            ]
        },
        {
            "id": "a2", "name": "Parliament of New Zealand", "type": "public", "role": "Legislature", "region": "Wellington",
            "description": "The supreme legislative body of New Zealand.",
            "events": [
                { "date": "1854-05-24", "type": "birth", "desc": "First parliament convened" },
                { "date": "1893-09-19", "type": "milestone", "desc": "Women's suffrage granted" },
                { "date": "1996-10-12", "type": "transformation", "desc": "MMP system adopted" }
            ]
        },
        {
            "id": "a3", "name": "University of Otago", "type": "public", "role": "Education", "region": "Dunedin",
            "description": "Oldest university in New Zealand.",
            "events": [
                { "date": "1869-01-01", "type": "birth", "desc": "Founded" },
                { "date": "1871-07-05", "type": "expansion", "desc": "First classes began" }
            ]
        },
        {
            "id": "a4", "name": "Bank of New Zealand", "type": "private", "role": "Finance", "region": "Auckland",
            "description": "One of New Zealand's largest banks.",
            "events": [
                { "date": "1861-07-29", "type": "birth", "desc": "Founded in Auckland" },
                { "date": "1945-01-01", "type": "milestone", "desc": "Largest bank by assets" }
            ]
        },
        {
            "id": "a5", "name": "New Zealand Railways", "type": "public", "role": "Transport", "region": "National",
            "description": "National railway system.",
            "events": [
                { "date": "1863-12-31", "type": "birth", "desc": "First railway opened" },
                { "date": "1993-07-01", "type": "privatization", "desc": "Privatized" },
                { "date": "2008-07-01", "type": "renationalization", "desc": "Renationalized" }
            ]
        },
        {
            "id": "a6", "name": "Air New Zealand", "type": "hybrid", "role": "Aviation", "region": "National",
            "description": "National airline carrier.",
            "events": [
                { "date": "1940-04-26", "type": "birth", "desc": "TEAL formed" },
                { "date": "1989-01-01", "type": "privatization", "desc": "Privatized" },
                { "date": "2001-09-13", "type": "renationalization", "desc": "Govt bailout" }
            ]
        },
        {
            "id": "a7", "name": "Waitangi Tribunal", "type": "public", "role": "Justice", "region": "National",
            "description": "Permanent commission of inquiry on Treaty claims.",
            "events": [
                { "date": "1975-10-10", "type": "birth", "desc": "Established by Act" }
            ]
        },
        {
            "id": "a8", "name": "Fonterra", "type": "hybrid", "role": "Dairy", "region": "National",
            "description": "New Zealand's largest dairy cooperative.",
            "events": [
                { "date": "2001-10-16", "type": "birth", "desc": "Merger formed Fonterra" }
            ]
        },
        {
            "id": "a9", "name": "Māori King Movement", "type": "hybrid", "role": "Cultural Leadership", "region": "Waikato",
            "description": "Māori sovereignty movement.",
            "events": [
                { "date": "1858-06-02", "type": "birth", "desc": "First Māori King installed" },
                { "date": "1863-07-12", "type": "conflict", "desc": "Waikato War invasion" }
            ]
        },
        {
            "id": "a10", "name": "Reserve Bank of NZ", "type": "public", "role": "Finance", "region": "National",
            "description": "Central bank.",
            "events": [
                { "date": "1934-08-01", "type": "birth", "desc": "Established" }
            ]
        }
    ]
    </script>

    <script>
        // ==========================================
        // DATA MODULE
        // ==========================================
        const DataModel = {
            actors: [],
            events: [], // Flattened event list for rendering
            selectedActor: null,

            init() {
                // Load data
                const rawData = JSON.parse(document.getElementById('data-json').textContent);
                this.actors = rawData;
                
                // Flatten events for scalable rendering
                // We add a reference back to the actor ID
                this.events = [];
                this.actors.forEach(actor => {
                    actor.events.forEach(ev => {
                        this.events.push({
                            x: 0, y: 0, // To be calculated by renderer
                            date: new Date(ev.date),
                            type: ev.type,
                            desc: ev.desc,
                            actorId: actor.id,
                            actorName: actor.name,
                            actorType: actor.type
                        });
                    });
                });

                // Sort events by date for potential optimizations
                this.events.sort((a, b) => a.date - b.date);
            },

            getEvents() {
                return this.events;
            },

            getActorById(id) {
                return this.actors.find(a => a.id === id);
            }
        };

        // ==========================================
        // RENDERER MODULE (Canvas)
        // ==========================================
        const Renderer = {
            canvas: null,
            ctx: null,
            axisCanvas: null,
            axisCtx: null,
            width: 0,
            height: 0,
            
            // State
            zoom: 1,
            panX: 0,
            isDragging: false,
            dragStartX: 0,
            panStartX: 0,
            
            // Time constraints
            minDate: new Date('1800-01-01').getTime(),
            maxDate: new Date('2024-12-31').getTime(),
            timeRange: 0,
            
            // Layout constants
            marginTop: 60,
            marginBottom: 40,
            marginLeft: 50,
            marginRight: 20,

            init() {
                this.canvas = document.getElementById('viz-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.axisCanvas = document.getElementById('axis-canvas');
                this.axisCtx = this.axisCanvas.getContext('2d');
                
                this.timeRange = this.maxDate - this.minDate;
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.loop();
            },

            resize() {
                const container = this.canvas.parentElement;
                this.width = container.clientWidth;
                this.height = container.clientHeight;
                
                // HiDPI support
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = this.width * dpr;
                this.canvas.height = this.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.height = this.height + 'px';

                // Axis canvas
                this.axisCanvas.width = this.width * dpr;
                this.axisCanvas.height = 40 * dpr;
                this.axisCtx.scale(dpr, dpr);
                this.axisCanvas.style.width = this.width + 'px';
                this.axisCanvas.style.height = '40px';
            },

            mapDateToX(timestamp) {
                // Normalized position 0..1
                const normalized = (timestamp - this.minDate) / this.timeRange;
                // Apply zoom and pan
                // Base width available for timeline
                const W = this.width - this.marginLeft - this.marginRight;
                // Scaled position
                const x = this.marginLeft + (normalized * W * this.zoom) + this.panX;
                return x;
            },

            mapXToDate(x) {
                 const W = this.width - this.marginLeft - this.marginRight;
                 const normalized = (x - this.marginLeft - this.panX) / (W * this.zoom);
                 return this.minDate + (normalized * this.timeRange);
            },

            drawAxis() {
                const ctx = this.axisCtx;
                ctx.clearRect(0, 0, this.width, 40);
                
                ctx.fillStyle = '#EDE9E0';
                ctx.fillRect(0, 0, this.width, 40);
                
                ctx.strokeStyle = '#78716C';
                ctx.fillStyle = '#4A4A4A';
                ctx.font = '11px "EB Garamond", serif';
                ctx.textAlign = 'center';

                // Determine step based on zoom
                const W = this.width - this.marginLeft - this.marginRight;
                const ms_per_pixel = this.timeRange / (W * this.zoom);
                
                // Target: roughly 100px between ticks
                const targetStepMs = ms_per_pixel * 100;
                
                // Define reasonable steps: 1yr, 5yr, 10yr, 25yr
                const year = 31536000000;
                let step = 10 * year;
                
                if (targetStepMs < 2 * year) step = 1 * year;
                else if (targetStepMs < 6 * year) step = 5 * year;
                else if (targetStepMs < 15 * year) step = 10 * year;
                else step = 25 * year;

                const startYear = 1800;
                const endYear = 2024;
                
                // Find first visible tick
                const leftDate = this.mapXToDate(this.marginLeft);
                const rightDate = this.mapXToDate(this.width - this.marginRight);
                
                let current = new Date(leftDate);
                current.setMonth(0, 1);
                current.setHours(0,0,0,0);
                
                // Round to step
                let years = Math.floor((current.getFullYear() - startYear) / (step/year));
                current.setFullYear(startYear + years * (step/year));

                while (current.getTime() < rightDate) {
                    if (current.getTime() > leftDate) {
                        const x = this.mapDateToX(current.getTime());
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, 10);
                        ctx.stroke();
                        ctx.fillText(current.getFullYear(), x, 26);
                    }
                    current = new Date(current.getTime() + step);
                }
            },

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);

                // Background
                ctx.fillStyle = '#F6F4EF';
                ctx.fillRect(0, 0, this.width, this.height);

                // Draw vertical "now" line or guide lines could go here
                
                // Determine layout bands for types
                // Public: Top, Hybrid: Middle, Private: Bottom
                const bandHeight = (this.height - this.marginTop - this.marginBottom) / 3;

                const bands = {
                    'public': { y: this.marginTop, h: bandHeight, color: '#1E3A5F' },
                    'hybrid': { y: this.marginTop + bandHeight, h: bandHeight, color: '#2D4A3E' },
                    'private': { y: this.marginTop + bandHeight * 2, h: bandHeight, color: '#7F1D1D' }
                };

                // Draw band separators
                ctx.strokeStyle = '#E0DCD2';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                Object.values(bands).forEach(b => {
                    ctx.beginPath();
                    ctx.moveTo(this.marginLeft, b.y + b.h);
                    ctx.lineTo(this.width - this.marginRight, b.y + b.h);
                    ctx.stroke();
                });
                ctx.setLineDash([]);

                // Render Events
                const events = DataModel.getEvents();
                const selectedId = DataModel.selectedActor ? DataModel.selectedActor.id : null;
                
                // To draw connections for selected actor, we need to collect points first
                let selectedPoints = [];

                events.forEach(ev => {
                    const x = this.mapDateToX(ev.date.getTime());
                    
                    // Optimization: Skip rendering if off-screen
                    if (x < this.marginLeft - 10 || x > this.width - this.marginRight + 10) return;

                    const band = bands[ev.actorType];
                    if (!band) return;

                    // Simple Y distribution (Randomized or fixed layout within band)
                    // For true scalability, we distribute within the band area
                    // We can use a hash of the ID or simple random to prevent overlap
                    const centerY = band.y + band.h / 2;
                    const spread = band.h * 0.4;
                    
                    // Deterministic Y position based on ID for stability
                    const hash = ev.actorId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const y = centerY + ((hash % 10) / 10 - 0.5) * spread;

                    ev.x = x;
                    ev.y = y;

                    // Visual Encoding
                    const isSelected = ev.actorId === selectedId;
                    const radius = isSelected ? 5 : 3;
                    const alpha = selectedId ? (isSelected ? 1.0 : 0.1) : 0.7;

                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    
                    // Color based on event type or actor type?
                    // Requirement: "encode actor types... lines, colors"
                    // We use Actor Type color as fill, Event Type might change shape later
                    let fillColor = band.color;
                    
                    // Event Type differentiation (Visual refinement)
                    if (ev.type === 'death') ctx.globalAlpha = 0.4;
                    else ctx.globalAlpha = alpha;

                    ctx.fillStyle = fillColor;
                    ctx.fill();

                    // Highlight stroke for selected
                    if (isSelected) {
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 1.5;
                        ctx.stroke();
                        selectedPoints.push({x, y, date: ev.date, desc: ev.desc, type: ev.type});
                    }
                    
                    ctx.globalAlpha = 1.0;
                });

                // Draw Consolidated Line for Selected Actor
                if (selectedPoints.length > 1) {
                    selectedPoints.sort((a,b) => a.x - b.x);
                    
                    ctx.beginPath();
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([2, 2]);
                    
                    ctx.moveTo(selectedPoints[0].x, selectedPoints[0].y);
                    selectedPoints.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                this.drawAxis();
            },

            loop() {
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        };

        // ==========================================
        // INTERACTION MODULE
        // ==========================================
        const Interaction = {
            hoveredEvent: null,

            init() {
                const canvas = Renderer.canvas;
                const tooltip = document.getElementById('tooltip');
                const sidebar = document.getElementById('sidebar');

                // Panning
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        Renderer.isDragging = true;
                        Renderer.dragStartX = e.clientX;
                        Renderer.panStartX = Renderer.panX;
                        canvas.style.cursor = 'grabbing';
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    if (Renderer.isDragging) {
                        const dx = e.clientX - Renderer.dragStartX;
                        Renderer.panX = Renderer.panStartX + dx;
                    } else {
                        // Hit detection
                        this.handleHover(e);
                    }
                });

                window.addEventListener('mouseup', () => {
                    Renderer.isDragging = false;
                    canvas.style.cursor = 'crosshair';
                });

                // Click to Consolidate
                canvas.addEventListener('click', (e) => {
                    const hit = this.findEvent(e.offsetX, e.offsetY);
                    if (hit) {
                        this.selectActor(hit.actorId);
                    } else {
                        this.deselectActor();
                    }
                });

                // Zoom
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    
                    // Zoom towards mouse position
                    const mouse_x = e.offsetX;
                    // Date at mouse before zoom
                    const dateAtMouse = Renderer.mapXToDate(mouse_x);
                    
                    Renderer.zoom *= zoomFactor;
                    Renderer.zoom = Math.max(0.5, Math.min(Renderer.zoom, 50)); // Limits

                    // Adjust pan to keep date under mouse
                    const new_x_for_date = Renderer.mapDateToX(dateAtMouse);
                    Renderer.panX += (mouse_x - new_x_for_date);
                });

                // Controls
                document.getElementById('btn-zoom-in').addEventListener('click', () => {
                    Renderer.zoom *= 1.2;
                });
                document.getElementById('btn-zoom-out').addEventListener('click', () => {
                    Renderer.zoom *= 0.8;
                });
                document.getElementById('btn-reset').addEventListener('click', () => {
                    Renderer.zoom = 1;
                    Renderer.panX = 0;
                });

                // Sidebar
                document.getElementById('close-sidebar').addEventListener('click', () => {
                    this.deselectActor();
                });
            },

            handleHover(e) {
                const hit = this.findEvent(e.offsetX, e.offsetY);
                const tooltip = document.getElementById('tooltip');
                
                if (hit) {
                    tooltip.style.left = (e.clientX + 15) + 'px';
                    tooltip.style.top = (e.clientY + 15) + 'px';
                    tooltip.style.opacity = 1;
                    
                    document.getElementById('tt-type').textContent = hit.type;
                    document.getElementById('tt-actor').textContent = hit.actorName;
                    document.getElementById('tt-desc').textContent = hit.desc;
                    document.getElementById('tt-date').textContent = hit.date.toLocaleDateString();
                } else {
                    tooltip.style.opacity = 0;
                }
            },

            findEvent(mx, my) {
                // Proximity search
                const events = DataModel.getEvents();
                const radius = 6; // Hit radius
                
                // Simple loop, could be optimized with QuadTree for massive datasets
                // For "thousands", a simple loop is instantaneous in JS.
                for (let i = events.length - 1; i >= 0; i--) {
                    const ev = events[i];
                    const dx = ev.x - mx;
                    const dy = ev.y - my;
                    if (dx * dx + dy * dy < radius * radius) {
                        return ev;
                    }
                }
                return null;
            },

            selectActor(id) {
                const actor = DataModel.getActorById(id);
                DataModel.selectedActor = actor;
                
                // Populate Sidebar
                const sb = document.getElementById('sidebar');
                sb.classList.add('open');
                
                document.getElementById('sb-name').textContent = actor.name;
                document.getElementById('sb-role').textContent = actor.role;
                document.getElementById('sb-type').textContent = actor.type;
                document.getElementById('sb-region').textContent = actor.region;
                document.getElementById('sb-desc').textContent = actor.description;
                
                // Timeline
                const tl = document.getElementById('sb-timeline');
                tl.innerHTML = '';

                // Sort events
                const sorted = [...actor.events].sort((a,b) => new Date(a.date) - new Date(b.date));
                
                sorted.forEach(ev => {
                    const div = document.createElement('div');
                    div.className = 'relative pl-4';
                    div.innerHTML = `
                        <div class="absolute -left-2 top-1 w-3 h-3 rounded-full border border-[var(--fg-primary)] bg-[var(--bg-primary)]"></div>
                        <div class="text-xs text-[var(--fg-muted)]">${new Date(ev.date).toLocaleDateString()}</div>
                        <div class="text-sm font-medium">${ev.type}</div>
                        <div class="text-xs italic">${ev.desc}</div>
                    `;
                    tl.appendChild(div);
                });

                Renderer.draw(); // Trigger immediate redraw
            },

            deselectActor() {
                DataModel.selectedActor = null;
                document.getElementById('sidebar').classList.remove('open');
                Renderer.draw();
            }
        };

        // ==========================================
        // BOOT
        // ==========================================
        window.addEventListener('DOMContentLoaded', () => {
            DataModel.init();
            Renderer.init();
            Interaction.init();
        });

    </script>
</body>
</html>