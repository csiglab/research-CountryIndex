<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Zealand Actor Space — Event Representation</title>
    
    <!-- Fonts: Elegant Oxford/Academic Style -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cormorant+Garamond:ital,wght@0,400;0,500;0,600;1,400&family=EB+Garamond:ital,wght@0,400;0,500;1,400&display=swap" rel="stylesheet">
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        :root {
            --bg-primary: #F6F4EF; /* Vellum */
            --bg-secondary: #EDE9E0;
            --fg-primary: #1A1A1A; /* Ink */
            --fg-secondary: #4A4A4A;
            --fg-muted: #78716C;
            --accent-public: #1E3A5F; /* Navy */
            --accent-private: #7F1D1D; /* Burgundy */
            --accent-hybrid: #2D4A3E; /* Forest */
            --border-subtle: #D1CCC0;
            --event-stroke: rgba(26, 26, 26, 0.8);
        }
        
        body {
            font-family: 'EB Garamond', serif;
            background-color: var(--bg-primary);
            color: var(--fg-primary);
        }
        
        .font-display {
            font-family: 'Cormorant Garamond', serif;
        }
        
        /* Canvas specific */
        #viz-canvas {
            cursor: crosshair;
        }
        
        /* Controls */
        .control-panel {
            background: rgba(246, 244, 239, 0.95);
            backdrop-filter: blur(8px);
            border-bottom: 1px solid var(--border-subtle);
        }
        
        .btn-classic {
            border: 1px solid var(--fg-muted);
            background: transparent;
            transition: all 0.2s ease;
        }
        .btn-classic:hover {
            background: var(--fg-primary);
            color: var(--bg-primary);
            border-color: var(--fg-primary);
        }
        
        /* Tooltip */
        .tooltip-box {
            position: absolute;
            background: #fff;
            border: 1px solid var(--fg-muted);
            padding: 12px 16px;
            pointer-events: none;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 100;
            max-width: 300px;
        }
        
        /* Detail Sidebar */
        .detail-sidebar {
            position: fixed;
            right: 0;
            top: 0;
            height: 100vh;
            width: 340px;
            background: var(--bg-primary);
            border-left: 1px solid var(--border-subtle);
            transform: translateX(100%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 50;
            overflow-y: auto;
            box-shadow: -4px 0 20px rgba(0,0,0,0.05);
        }
        .detail-sidebar.open {
            transform: translateX(0);
        }

        /* Timeline Axis */
        .time-axis {
            height: 40px;
            border-top: 1px solid var(--fg-muted);
            background: var(--bg-secondary);
        }

        /* Loading State */
        #loading-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Cormorant Garamond', serif;
            font-size: 1.5rem;
            color: var(--fg-muted);
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body class="overflow-hidden">

    <!-- Header -->
    <header class="control-panel py-4 px-6 flex justify-between items-center z-10 relative">
        <div>
            <h1 class="font-display text-2xl font-medium tracking-wide">New Zealand Actor Space</h1>
            <p class="text-xs text-[var(--fg-muted)] uppercase tracking-widest mt-1">Event-Based Temporal Representation, 1800–Present</p>
        </div>
        <div class="flex items-center gap-4 text-sm">
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 rounded-full bg-[var(--accent-public)]"></div>
                <span>Public</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 rounded-full bg-[var(--accent-private)]"></div>
                <span>Private</span>
            </div>
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 rounded-full bg-[var(--accent-hybrid)]"></div>
                <span>Hybrid</span>
            </div>
        </div>
    </header>

    <!-- Main Visualization -->
    <main class="relative flex flex-col" style="height: calc(100vh - 80px);">
        
        <!-- Filters / Controls -->
        <div class="absolute top-4 left-4 z-20 flex gap-2">
            <button id="btn-zoom-in" class="btn-classic px-3 py-1 text-sm rounded-sm">+</button>
            <button id="btn-zoom-out" class="btn-classic px-3 py-1 text-sm rounded-sm">−</button>
            <button id="btn-reset" class="btn-classic px-3 py-1 text-sm rounded-sm">Reset View</button>
        </div>

        <!-- The Canvas -->
        <div class="flex-1 relative">
            <canvas id="viz-canvas"></canvas>
            
            <!-- Hover Tooltip -->
            <div id="tooltip" class="tooltip-box font-display">
                <div class="text-xs text-[var(--fg-muted)] uppercase tracking-wider" id="tt-type">Event Type</div>
                <div class="text-lg font-medium" id="tt-actor">Actor Name</div>
                <div class="text-sm italic" id="tt-desc">Description</div>
                <div class="mt-2 text-xs font-mono" id="tt-date">Date</div>
            </div>

            <!-- Loading Message -->
            <div id="loading-indicator">Loading actor-set.json...</div>
        </div>

        <!-- Time Axis -->
        <div class="time-axis relative z-10">
            <canvas id="axis-canvas"></canvas>
        </div>
        
    </main>

    <!-- Detail Sidebar (Consolidated Actor View) -->
    <aside id="sidebar" class="detail-sidebar p-6">
        <button id="close-sidebar" class="absolute top-4 right-4 text-sm opacity-50 hover:opacity-100 transition-opacity p-2">✕</button>
        <div class="border-b border-[var(--border-subtle)] pb-4 mb-4 mt-4">
            <h2 class="font-display text-3xl font-medium leading-tight" id="sb-name">Actor Name</h2>
            <p class="text-sm text-[var(--fg-muted)] uppercase tracking-wider mt-2" id="sb-role">Role</p>
        </div>
        
        <div class="space-y-4">
            <div>
                <h3 class="text-xs uppercase tracking-wider text-[var(--fg-muted)] mb-1">Type</h3>
                <p id="sb-type" class="text-sm font-medium">Public</p>
            </div>
            <div>
                <h3 class="text-xs uppercase tracking-wider text-[var(--fg-muted)] mb-1">Region</h3>
                <p id="sb-region" class="text-sm">Region</p>
            </div>
            <div>
                <h3 class="text-xs uppercase tracking-wider text-[var(--fg-muted)] mb-1">Description</h3>
                <p id="sb-desc" class="text-sm italic leading-relaxed">Description text...</p>
            </div>
            
            <!-- Consolidated Timeline in Sidebar -->
            <div class="mt-8 pt-4 border-t border-[var(--border-subtle)]">
                <h3 class="text-xs uppercase tracking-wider text-[var(--fg-muted)] mb-4">Consolidated Event Sequence</h3>
                <div id="sb-timeline" class="space-y-6 pl-4 border-l-2 border-[var(--fg-muted)]">
                    <!-- Events will be injected here -->
                </div>
            </div>
        </div>
    </aside>

    <!-- Fallback Data (Used if actor-set.json is missing) -->
    <script type="application/json" id="fallback-data">
    [
        {
            "id": "a1", "name": "New Zealand Company", "type": "private", "role": "Colonization", "regionOfActivity": "Wellington",
            "description": "Private British company instrumental in the early colonization.",
            "events": [
                { "date": "1839-05-02", "category": "birth", "description": "Established in London" },
                { "date": "1841-01-22", "category": "expansion", "description": "Wellington settlement founded" },
                { "date": "1858-12-31", "category": "death", "description": "Dissolution" }
            ]
        },
        {
            "id": "a2", "name": "Parliament of New Zealand", "type": "public", "role": "Legislature", "regionOfActivity": "Wellington",
            "description": "The supreme legislative body of New Zealand.",
            "events": [
                { "date": "1854-05-24", "category": "birth", "description": "First parliament convened" },
                { "date": "1893-09-19", "category": "milestone", "description": "Women's suffrage granted" },
                { "date": "1996-10-12", "category": "transformation", "description": "MMP system adopted" }
            ]
        },
        {
            "id": "a3", "name": "University of Otago", "type": "public", "role": "Education", "regionOfActivity": "Dunedin",
            "description": "Oldest university in New Zealand.",
            "events": [
                { "date": "1869-01-01", "category": "birth", "description": "Founded" },
                { "date": "1871-07-05", "category": "expansion", "description": "First classes began" }
            ]
        },
        {
            "id": "a4", "name": "Bank of New Zealand", "type": "private", "role": "Finance", "regionOfActivity": "Auckland",
            "description": "One of New Zealand's largest banks.",
            "events": [
                { "date": "1861-07-29", "category": "birth", "description": "Founded in Auckland" },
                { "date": "1945-01-01", "category": "milestone", "description": "Largest bank by assets" }
            ]
        },
        {
            "id": "a5", "name": "New Zealand Railways", "type": "public", "role": "Transport", "regionOfActivity": "National",
            "description": "National railway system.",
            "events": [
                { "date": "1863-12-31", "category": "birth", "description": "First railway opened" },
                { "date": "1993-07-01", "category": "privatization", "description": "Privatized" },
                { "date": "2008-07-01", "category": "renationalization", "description": "Renationalized" }
            ]
        },
        {
            "id": "a6", "name": "Air New Zealand", "type": "hybrid", "role": "Aviation", "regionOfActivity": "National",
            "description": "National airline carrier.",
            "events": [
                { "date": "1940-04-26", "category": "birth", "description": "TEAL formed" },
                { "date": "1989-01-01", "category": "privatization", "description": "Privatized" },
                { "date": "2001-09-13", "category": "renationalization", "description": "Govt bailout" }
            ]
        },
        {
            "id": "a7", "name": "Waitangi Tribunal", "type": "public", "role": "Justice", "regionOfActivity": "National",
            "description": "Permanent commission of inquiry on Treaty claims.",
            "events": [
                { "date": "1975-10-10", "category": "birth", "description": "Established by Act" }
            ]
        },
        {
            "id": "a8", "name": "Fonterra", "type": "hybrid", "role": "Dairy", "regionOfActivity": "National",
            "description": "New Zealand's largest dairy cooperative.",
            "events": [
                { "date": "2001-10-16", "category": "birth", "description": "Merger formed Fonterra" }
            ]
        },
        {
            "id": "a9", "name": "Māori King Movement", "type": "hybrid", "role": "Cultural Leadership", "regionOfActivity": "Waikato",
            "description": "Māori sovereignty movement.",
            "events": [
                { "date": "1858-06-02", "category": "birth", "description": "First Māori King installed" },
                { "date": "1863-07-12", "category": "conflict", "description": "Waikato War invasion" }
            ]
        },
        {
            "id": "a10", "name": "Reserve Bank of NZ", "type": "public", "role": "Finance", "regionOfActivity": "National",
            "description": "Central bank.",
            "events": [
                { "date": "1934-08-01", "category": "birth", "description": "Established" }
            ]
        }
    ]
    </script>

    <script>
        // ==========================================
        // DATA MODULE
        // ==========================================
        const DataModel = {
            actors: [],
            events: [], // Flattened event list for rendering
            selectedActor: null,

            async init() {
                const loadingEl = document.getElementById('loading-indicator');
                
                try {
                    // Try to fetch the external file
                    const response = await fetch('actor-set.json');
                    
                    if (!response.ok) {
                        throw new Error(`HTTP Error: ${response.status}`);
                    }
                    
                    const rawData = await response.json();
                    console.log("Successfully loaded actor-set.json");
                    this.processData(rawData);
                    
                } catch (error) {
                    console.warn("Could not load actor-set.json (likely CORS or file missing). Using fallback data.", error);
                    
                    // Fallback: Load embedded JSON
                    const fallbackText = document.getElementById('fallback-data').textContent;
                    const rawData = JSON.parse(fallbackText);
                    this.processData(rawData);
                } finally {
                    // Hide loading indicator
                    loadingEl.style.opacity = '0';
                }
            },

            processData(rawData) {
                // Schema normalization: 
                // The provided schema has a root object { metadata, region, actors }.
                // The fallback data is just an array [actors].
                // We handle both cases here.
                this.actors = rawData.actors || (Array.isArray(rawData) ? rawData : []);
                
                // Flatten events for scalable rendering
                this.events = [];
                this.actors.forEach(actor => {
                    // Ensure actor has events array
                    if (!actor.events) return;

                    actor.events.forEach(ev => {
                        // Schema Mapping:
                        // Schema: 'date', 'category', 'description'
                        // Internal: 'date', 'type', 'desc'
                        // We normalize 'category' -> 'type' and 'description' -> 'desc'
                        
                        const eventDate = new Date(ev.date);
                        if (isNaN(eventDate.getTime())) return; // Skip invalid dates

                        this.events.push({
                            x: 0, y: 0, // To be calculated by renderer
                            date: eventDate,
                            type: ev.category || ev.type || 'general', // Prefer category (schema), fallback to type (old format)
                            desc: ev.description || ev.desc || '',      // Prefer description (schema)
                            actorId: actor.id,
                            actorName: actor.name,
                            actorType: actor.type
                        });
                    });
                });

                // Sort events by date
                this.events.sort((a, b) => a.date - b.date);
            },

            getEvents() {
                return this.events;
            },

            getActorById(id) {
                return this.actors.find(a => a.id === id);
            }
        };

        // ==========================================
        // RENDERER MODULE (Canvas)
        // ==========================================
        const Renderer = {
            canvas: null,
            ctx: null,
            axisCanvas: null,
            axisCtx: null,
            width: 0,
            height: 0,
            
            // State
            zoom: 1,
            panX: 0,
            isDragging: false,
            dragStartX: 0,
            panStartX: 0,
            
            // Time constraints
            minDate: new Date('1800-01-01').getTime(),
            maxDate: new Date('2025-12-31').getTime(), // Extended slightly
            timeRange: 0,
            
            // Layout constants
            marginTop: 60,
            marginBottom: 40,
            marginLeft: 50,
            marginRight: 20,

            init() {
                this.canvas = document.getElementById('viz-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.axisCanvas = document.getElementById('axis-canvas');
                this.axisCtx = this.axisCanvas.getContext('2d');
                
                this.timeRange = this.maxDate - this.minDate;
                
                this.resize();
                window.addEventListener('resize', () => this.resize());
                
                this.loop();
            },

            resize() {
                const container = this.canvas.parentElement;
                this.width = container.clientWidth;
                this.height = container.clientHeight;
                
                // HiDPI support
                const dpr = window.devicePixelRatio || 1;
                this.canvas.width = this.width * dpr;
                this.canvas.height = this.height * dpr;
                this.ctx.scale(dpr, dpr);
                this.canvas.style.width = this.width + 'px';
                this.canvas.style.height = this.height + 'px';

                // Axis canvas
                this.axisCanvas.width = this.width * dpr;
                this.axisCanvas.height = 40 * dpr;
                this.axisCtx.scale(dpr, dpr);
                this.axisCanvas.style.width = this.width + 'px';
                this.axisCanvas.style.height = '40px';
            },

            mapDateToX(timestamp) {
                // Normalized position 0..1
                const normalized = (timestamp - this.minDate) / this.timeRange;
                // Apply zoom and pan
                const W = this.width - this.marginLeft - this.marginRight;
                // Scaled position
                const x = this.marginLeft + (normalized * W * this.zoom) + this.panX;
                return x;
            },

            mapXToDate(x) {
                 const W = this.width - this.marginLeft - this.marginRight;
                 const normalized = (x - this.marginLeft - this.panX) / (W * this.zoom);
                 return this.minDate + (normalized * this.timeRange);
            },

            drawAxis() {
                const ctx = this.axisCtx;
                ctx.clearRect(0, 0, this.width, 40);
                
                ctx.fillStyle = '#EDE9E0';
                ctx.fillRect(0, 0, this.width, 40);
                
                ctx.strokeStyle = '#78716C';
                ctx.fillStyle = '#4A4A4A';
                ctx.font = '11px "EB Garamond", serif';
                ctx.textAlign = 'center';

                // Determine step based on zoom
                const W = this.width - this.marginLeft - this.marginRight;
                const ms_per_pixel = this.timeRange / (W * this.zoom);
                
                // Target: roughly 100px between ticks
                const targetStepMs = ms_per_pixel * 100;
                
                // Define reasonable steps
                const year = 31536000000;
                let step = 10 * year;
                
                if (targetStepMs < 2 * year) step = 1 * year;
                else if (targetStepMs < 6 * year) step = 5 * year;
                else if (targetStepMs < 15 * year) step = 10 * year;
                else step = 25 * year;

                const startYear = 1800;
                const endYear = 2025;
                
                // Find visible range
                const leftDate = this.mapXToDate(this.marginLeft);
                const rightDate = this.mapXToDate(this.width - this.marginRight);
                
                let current = new Date(leftDate);
                current.setMonth(0, 1);
                current.setHours(0,0,0,0);
                
                // Snap to step
                let years = Math.floor((current.getFullYear() - startYear) / (step/year));
                current.setFullYear(startYear + years * (step/year));

                while (current.getTime() < rightDate) {
                    if (current.getTime() > leftDate) {
                        const x = this.mapDateToX(current.getTime());
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, 10);
                        ctx.stroke();
                        ctx.fillText(current.getFullYear(), x, 26);
                    }
                    current = new Date(current.getTime() + step);
                }
            },

            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);

                // Background
                ctx.fillStyle = '#F6F4EF';
                ctx.fillRect(0, 0, this.width, this.height);
                
                // Draw vertical "now" line (approximate)
                // const nowX = this.mapDateToX(new Date().getTime());
                // if (nowX > this.marginLeft && nowX < this.width) {
                //     ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                //     ctx.beginPath();
                //     ctx.moveTo(nowX, 0);
                //     ctx.lineTo(nowX, this.height);
                //     ctx.stroke();
                // }
                
                // Determine layout bands for types
                const bandHeight = (this.height - this.marginTop - this.marginBottom) / 3;

                const bands = {
                    'public': { y: this.marginTop, h: bandHeight, color: '#1E3A5F' },
                    'hybrid': { y: this.marginTop + bandHeight, h: bandHeight, color: '#2D4A3E' },
                    'private': { y: this.marginTop + bandHeight * 2, h: bandHeight, color: '#7F1D1D' }
                };

                // Draw band separators
                ctx.strokeStyle = '#E0DCD2';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                Object.values(bands).forEach(b => {
                    ctx.beginPath();
                    ctx.moveTo(this.marginLeft, b.y + b.h);
                    ctx.lineTo(this.width - this.marginRight, b.y + b.h);
                    ctx.stroke();
                });
                ctx.setLineDash([]);

                // Render Events
                const events = DataModel.getEvents();
                const selectedId = DataModel.selectedActor ? DataModel.selectedActor.id : null;
                let selectedPoints = [];

                events.forEach(ev => {
                    const x = this.mapDateToX(ev.date.getTime());
                    
                    // Optimization: Skip rendering if off-screen
                    if (x < this.marginLeft - 10 || x > this.width - this.marginRight + 10) return;

                    const band = bands[ev.actorType];
                    if (!band) return;

                    // Deterministic Y position
                    const centerY = band.y + band.h / 2;
                    const spread = band.h * 0.35;
                    
                    // Hash ID for stable distribution
                    const hash = ev.actorId.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
                    const y = centerY + ((hash % 10) / 10 - 0.5) * spread;

                    ev.x = x;
                    ev.y = y;

                    const isSelected = ev.actorId === selectedId;
                    const radius = isSelected ? 6 : 3.5;
                    const alpha = selectedId ? (isSelected ? 1.0 : 0.1) : 0.8;

                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    
                    // Color handling
                    let fillColor = band.color;
                    if (ev.type === 'death') ctx.globalAlpha = alpha * 0.5;
                    else ctx.globalAlpha = alpha;

                    ctx.fillStyle = fillColor;
                    ctx.fill();

                    if (isSelected) {
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                        selectedPoints.push({x, y, date: ev.date, desc: ev.desc, type: ev.type});
                    }
                    
                    ctx.globalAlpha = 1.0;
                });

                // Draw Connector Line for Selected Actor
                if (selectedPoints.length > 1) {
                    selectedPoints.sort((a,b) => a.x - b.x);
                    
                    ctx.beginPath();
                    ctx.strokeStyle = '#1A1A1A'; // Dark ink color
                    ctx.lineWidth = 1.5;
                    ctx.setLineDash([4, 4]); // Dashed line for temporal connection
                    
                    ctx.moveTo(selectedPoints[0].x, selectedPoints[0].y);
                    selectedPoints.forEach(p => ctx.lineTo(p.x, p.y));
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
                
                this.drawAxis();
            },

            loop() {
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        };

        // ==========================================
        // INTERACTION MODULE
        // ==========================================
        const Interaction = {
            hoveredEvent: null,

            init() {
                const canvas = Renderer.canvas;
                const tooltip = document.getElementById('tooltip');
                const sidebar = document.getElementById('sidebar');

                // Panning
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 0) {
                        Renderer.isDragging = true;
                        Renderer.dragStartX = e.clientX;
                        Renderer.panStartX = Renderer.panX;
                        canvas.style.cursor = 'grabbing';
                    }
                });

                window.addEventListener('mousemove', (e) => {
                    if (Renderer.isDragging) {
                        const dx = e.clientX - Renderer.dragStartX;
                        Renderer.panX = Renderer.panStartX + dx;
                    } else {
                        // Hit detection only if not dragging
                        const rect = canvas.getBoundingClientRect();
                        this.handleHover(e.clientX - rect.left, e.clientY - rect.top, e.clientX, e.clientY);
                    }
                });

                window.addEventListener('mouseup', () => {
                    Renderer.isDragging = false;
                    canvas.style.cursor = 'crosshair';
                });

                // Click to Select
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const hit = this.findEvent(e.clientX - rect.left, e.clientY - rect.top);
                    if (hit) {
                        this.selectActor(hit.actorId);
                    } else {
                        // Deselect if clicked on empty space (and not dragging)
                        // Simple check: if mouse moved significantly, it was a drag
                        this.deselectActor();
                    }
                });

                // Zoom
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    
                    const mouse_x = e.offsetX;
                    const dateAtMouse = Renderer.mapXToDate(mouse_x);
                    
                    Renderer.zoom *= zoomFactor;
                    Renderer.zoom = Math.max(0.5, Math.min(Renderer.zoom, 50)); 

                    const new_x_for_date = Renderer.mapDateToX(dateAtMouse);
                    Renderer.panX += (mouse_x - new_x_for_date);
                }, { passive: false });

                // Controls
                document.getElementById('btn-zoom-in').addEventListener('click', () => {
                    Renderer.zoom *= 1.2;
                });
                document.getElementById('btn-zoom-out').addEventListener('click', () => {
                    Renderer.zoom *= 0.8;
                });
                document.getElementById('btn-reset').addEventListener('click', () => {
                    Renderer.zoom = 1;
                    Renderer.panX = 0;
                });

                // Sidebar Close
                document.getElementById('close-sidebar').addEventListener('click', () => {
                    this.deselectActor();
                });
            },

            handleHover(canvasX, canvasY, clientX, clientY) {
                const hit = this.findEvent(canvasX, canvasY);
                const tooltip = document.getElementById('tooltip');
                
                if (hit) {
                    // Ensure tooltip stays within viewport
                    let left = clientX + 15;
                    let top = clientY + 15;
                    
                    tooltip.style.left = left + 'px';
                    tooltip.style.top = top + 'px';
                    tooltip.style.opacity = 1;
                    
                    document.getElementById('tt-type').textContent = hit.type;
                    document.getElementById('tt-actor').textContent = hit.actorName;
                    document.getElementById('tt-desc').textContent = hit.desc;
                    document.getElementById('tt-date').textContent = hit.date.toLocaleDateString(undefined, {
                        year: 'numeric', month: 'short', day: 'numeric'
                    });
                } else {
                    tooltip.style.opacity = 0;
                }
            },

            findEvent(mx, my) {
                const events = DataModel.getEvents();
                const radius = 8; // Generous hit radius
                
                // Search backwards to find top-most rendered item first
                for (let i = events.length - 1; i >= 0; i--) {
                    const ev = events[i];
                    const dx = ev.x - mx;
                    const dy = ev.y - my;
                    if (dx * dx + dy * dy < radius * radius) {
                        return ev;
                    }
                }
                return null;
            },

            selectActor(id) {
                const actor = DataModel.getActorById(id);
                DataModel.selectedActor = actor;
                
                // Populate Sidebar
                const sb = document.getElementById('sidebar');
                sb.classList.add('open');
                
                document.getElementById('sb-name').textContent = actor.name;
                document.getElementById('sb-role').textContent = actor.role;
                
                // Capitalize type for display
                const typeDisplay = actor.type.charAt(0).toUpperCase() + actor.type.slice(1);
                document.getElementById('sb-type').textContent = typeDisplay;
                
                // Handle regionOfActivity (schema) vs region (fallback)
                document.getElementById('sb-region').textContent = actor.regionOfActivity || actor.region || 'Unknown';
                document.getElementById('sb-desc').textContent = actor.description || 'No description available.';
                
                // Timeline
                const tl = document.getElementById('sb-timeline');
                tl.innerHTML = '';

                const sorted = [...actor.events].sort((a,b) => new Date(a.date) - new Date(b.date));
                
                sorted.forEach(ev => {
                    const div = document.createElement('div');
                    div.className = 'relative pl-6 group';
                    
                    // Determine color based on category
                    let dotColor = 'var(--fg-primary)';
                    if (ev.category === 'birth') dotColor = 'var(--accent-public)';
                    if (ev.category === 'death') dotColor = 'var(--accent-private)';

                    div.innerHTML = `
                        <div class="absolute -left-[5px] top-1.5 w-2.5 h-2.5 rounded-full border border-[var(--fg-primary)] bg-[var(--bg-primary)] group-hover:bg-[var(--fg-secondary)] transition-colors"></div>
                        <div class="text-xs text-[var(--fg-muted)] font-mono mb-0.5">${new Date(ev.date).toLocaleDateString()}</div>
                        <div class="text-sm font-medium text-[var(--fg-primary)] capitalize">${ev.category || ev.type || 'Event'}</div>
                        <div class="text-sm text-[var(--fg-secondary)] leading-snug">${ev.description || ev.desc || ''}</div>
                    `;
                    tl.appendChild(div);
                });

                Renderer.draw();
            },

            deselectActor() {
                DataModel.selectedActor = null;
                document.getElementById('sidebar').classList.remove('open');
                Renderer.draw();
            }
        };

        // ==========================================
        // BOOT
        // ==========================================
        window.addEventListener('DOMContentLoaded', () => {
            // Initialize Data (Async fetch)
            DataModel.init().then(() => {
                // Once data is loaded (or failed over), init visuals
                Renderer.init();
                Interaction.init();
            });
        });

    </script>
</body>
</html>