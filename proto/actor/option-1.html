<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Actor Timeline Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            padding: 24px 32px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 16px;
        }

        .header h1 {
            font-size: 24px;
            font-weight: 600;
            letter-spacing: -0.5px;
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
        }

        .search-box {
            position: relative;
        }

        .search-box input {
            padding: 10px 16px 10px 40px;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: white;
            font-size: 14px;
            width: 280px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }

        .search-box input::placeholder {
            color: rgba(255,255,255,0.7);
        }

        .search-box input:focus {
            outline: none;
            background: rgba(255,255,255,0.3);
            width: 320px;
        }

        .search-box::before {
            content: "üîç";
            position: absolute;
            left: 12px;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0.7;
        }

        .filter-tabs {
            display: flex;
            gap: 8px;
            background: rgba(255,255,255,0.1);
            padding: 4px;
            border-radius: 8px;
        }

        .filter-tab {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: rgba(255,255,255,0.8);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.3s ease;
        }

        .filter-tab:hover {
            color: white;
            background: rgba(255,255,255,0.1);
        }

        .filter-tab.active {
            background: white;
            color: #667eea;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .main-content {
            display: flex;
            height: 700px;
        }

        .chart-area {
            flex: 1;
            position: relative;
            padding: 20px;
        }

        .sidebar {
            width: 60px;
            background: #f8f9fa;
            border-left: 1px solid #e9ecef;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px 0;
            gap: 8px;
        }

        .tool-btn {
            width: 40px;
            height: 40px;
            border: none;
            background: white;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            color: #6c757d;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
        }

        .tool-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .tool-btn:active {
            transform: translateY(0);
        }

        .tool-divider {
            width: 30px;
            height: 1px;
            background: #dee2e6;
            margin: 8px 0;
        }

        .minimap {
            width: 50px;
            height: 200px;
            background: white;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            margin-top: auto;
            position: relative;
            overflow: hidden;
        }

        .minimap-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        .minimap-brush {
            position: absolute;
            left: 0;
            right: 0;
            background: rgba(102, 126, 234, 0.3);
            border: 2px solid #667eea;
            border-radius: 4px;
            cursor: ns-resize;
        }

        #chart {
            width: 100%;
            height: 100%;
        }

        .axis {
            font-size: 12px;
        }

        .axis path,
        .axis line {
            stroke: #e9ecef;
        }

        .axis text {
            fill: #6c757d;
        }

        .grid line {
            stroke: #f1f3f5;
            stroke-dasharray: 3,3;
        }

        .data-point {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .data-point:hover {
            filter: brightness(1.2);
            transform: scale(1.2);
        }

        .data-point.dimmed {
            opacity: 0.1;
        }

        .tooltip {
            position: absolute;
            padding: 12px 16px;
            background: rgba(0,0,0,0.9);
            color: white;
            border-radius: 8px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1000;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            max-width: 250px;
        }

        .tooltip strong {
            display: block;
            margin-bottom: 4px;
            font-size: 14px;
            color: #fff;
        }

        .tooltip span {
            color: #adb5bd;
            font-size: 12px;
        }

        .bottom-controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: white;
            padding: 8px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        .time-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            color: #6c757d;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.2s;
        }

        .time-btn:hover {
            background: #f8f9fa;
            color: #495057;
        }

        .time-btn.active {
            background: #667eea;
            color: white;
        }

        .legend {
            position: absolute;
            top: 20px;
            right: 80px;
            background: rgba(255,255,255,0.95);
            padding: 16px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            backdrop-filter: blur(10px);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 13px;
            color: #495057;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .legend-item:hover {
            opacity: 0.7;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-symbol {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .legend-symbol.circle {
            border-radius: 50%;
        }

        .legend-symbol.triangle {
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 12px solid currentColor;
            background: transparent !important;
        }

        .connection-line {
            fill: none;
            stroke: #adb5bd;
            stroke-width: 1;
            stroke-dasharray: 5,5;
            opacity: 0.5;
        }

        @media (max-width: 968px) {
            .main-content {
                flex-direction: column;
                height: auto;
            }
            
            .sidebar {
                width: 100%;
                height: 60px;
                flex-direction: row;
                justify-content: center;
                border-left: none;
                border-top: 1px solid #e9ecef;
            }
            
            .minimap {
                display: none;
            }
            
            .chart-area {
                height: 500px;
            }
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: #6c757d;
        }

        .brush .selection {
            fill: rgba(102, 126, 234, 0.2);
            stroke: #667eea;
            stroke-width: 1;
        }
    </style>
<base target="_blank">
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Actor Timeline Explorer</h1>
            <div class="controls">
                <div class="search-box">
                    <input type="text" id="searchInput" placeholder="Search actors by name...">
                </div>
                <div class="filter-tabs">
                    <button class="filter-tab active" data-filter="all">All</button>
                    <button class="filter-tab" data-filter="private">Private</button>
                    <button class="filter-tab" data-filter="hybrid">Hybrid</button>
                    <button class="filter-tab" data-filter="public">Public</button>
                </div>
            </div>
        </div>
        
        <div class="main-content">
            <div class="chart-area">
                <div id="chart"></div>
                <div class="tooltip" id="tooltip"></div>
                
                <div class="legend">
                    <div class="legend-item" data-type="private">
                        <div class="legend-symbol circle" style="background: #4a90e2;"></div>
                        <span>Private</span>
                    </div>
                    <div class="legend-item" data-type="hybrid">
                        <div class="legend-symbol" style="background: #f5a623;"></div>
                        <span>Hybrid</span>
                    </div>
                    <div class="legend-item" data-type="public">
                        <div class="legend-symbol triangle" style="color: #d0021b;"></div>
                        <span>Public</span>
                    </div>
                </div>
                
                <div class="bottom-controls">
                    <button class="time-btn" data-year="1800">1800</button>
                    <button class="time-btn" data-year="1850">1850</button>
                    <button class="time-btn active" data-year="1900">1900</button>
                    <button class="time-btn" data-year="1950">1950</button>
                    <button class="time-btn" data-year="2000">2000</button>
                </div>
            </div>
            
            <div class="sidebar">
                <button class="tool-btn" id="zoomIn" title="Zoom In">+</button>
                <button class="tool-btn" id="zoomOut" title="Zoom Out">‚àí</button>
                <div class="tool-divider"></div>
                <button class="tool-btn" id="resetZoom" title="Reset View">‚ü≤</button>
                <button class="tool-btn" id="fullscreen" title="Fullscreen">‚õ∂</button>
                <div class="tool-divider"></div>
                <button class="tool-btn" id="help" title="Help">?</button>
                
                <div class="minimap">
                    <div class="minimap-content" id="minimap"></div>
                    <div class="minimap-brush" id="minimapBrush" style="top: 20%; height: 30%;"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Sample data generation based on the visual patterns
        const generateData = () => {
            const data = [];
            
            // Private actors (blue circles) - left cluster around 1880s-1980s
            const privateActors = [
                {name: "John Private", birth: 1880, death: 1940, type: "private"},
                {name: "Sarah Private", birth: 1875, death: 1950, type: "private"},
                {name: "Michael Private", birth: 1885, death: 1960, type: "private"},
                {name: "Emma Private", birth: 1878, death: 1935, type: "private"},
                {name: "William Private", birth: 1890, death: 1980, type: "private"},
                {name: "Olivia Private", birth: 1882, death: 1945, type: "private"},
                {name: "James Private", birth: 1895, death: 1990, type: "private"},
                {name: "Sophia Private", birth: 1980, death: 2020, type: "private"},
                {name: "Benjamin Private", birth: 1985, death: null, type: "private"},
                {name: "Ava Private", birth: 1990, death: null, type: "private"}
            ];
            
            // Hybrid actors (orange squares) - middle cluster
            const hybridActors = [
                {name: "Robert Hybrid", birth: 1920, death: 1980, type: "hybrid"},
                {name: "Mia Hybrid", birth: 1925, death: 1990, type: "hybrid"},
                {name: "David Hybrid", birth: 1950, death: 2010, type: "hybrid"},
                {name: "Isabella Hybrid", birth: 1970, death: 2020, type: "hybrid"},
                {name: "Joseph Hybrid", birth: 2020, death: null, type: "hybrid"}
            ];
            
            // Public actors (red triangles) - right cluster around 1850s-2010s
            const publicActors = [
                {name: "Thomas Public", birth: 1860, death: 1920, type: "public"},
                {name: "Charlotte Public", birth: 1865, death: 1930, type: "public"},
                {name: "Daniel Public", birth: 1880, death: 1940, type: "public"},
                {name: "Amelia Public", birth: 1885, death: 1950, type: "public"},
                {name: "Matthew Public", birth: 1950, death: 2020, type: "public"},
                {name: "Harper Public", birth: 2010, death: null, type: "public"}
            ];
            
            return [...privateActors, ...hybridActors, ...publicActors].map((d, i) => ({
                ...d,
                id: i,
                y: d.birth + (Math.random() * 20 - 10) // Slight variation for visual spread
            }));
        };

        const data = generateData();
        
        // Setup dimensions
        const margin = {top: 40, right: 60, bottom: 60, left: 80};
        let width, height;
        
        const container = d3.select("#chart");
        const tooltip = d3.select("#tooltip");
        
        // Create SVG
        const svg = container.append("svg")
            .attr("width", "100%")
            .attr("height", "100%");
            
        const g = svg.append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
            
        // Scales
        let xScale, yScale;
        let currentTransform = d3.zoomIdentity;

        // Color and shape mapping
        const colorMap = {
            private: "#4a90e2",
            hybrid: "#f5a623",
            public: "#d0021b"
        };
        
        // Clip path
        svg.append("defs").append("clipPath")
            .attr("id", "clip")
            .append("rect")
            .attr("width", "100%")
            .attr("height", "100%");
            
        const chartBody = g.append("g")
            .attr("clip-path", "url(#clip)");
            
        // Grid lines group
        const gridGroup = g.append("g")
            .attr("class", "grid");
            
        // Axes groups
        const xAxisGroup = g.append("g")
            .attr("class", "axis x-axis");
            
        const yAxisGroup = g.append("g")
            .attr("class", "axis y-axis");
            
        // Connections group
        const connectionsGroup = chartBody.append("g")
            .attr("class", "connections");
            
        // Points group
        const pointsGroup = chartBody.append("g")
            .attr("class", "points");

        function updateDimensions() {
            const containerRect = container.node().getBoundingClientRect();
            width = containerRect.width - margin.left - margin.right;
            height = containerRect.height - margin.top - margin.bottom;
            
            svg.attr("viewBox", `0 0 ${containerRect.width} ${containerRect.height}`);
            
            xScale = d3.scaleLinear()
                .domain([1750, 2030])
                .range([0, width]);
                
            yScale = d3.scaleLinear()
                .domain([1800, 2025])
                .range([0, height]);
                
            return {width, height};
        }

        function drawGrid() {
            // Vertical grid lines
            const xTicks = xScale.ticks(10);
            gridGroup.selectAll(".grid-x")
                .data(xTicks)
                .join("line")
                .attr("class", "grid-x")
                .attr("x1", d => xScale(d))
                .attr("x2", d => xScale(d))
                .attr("y1", 0)
                .attr("y2", height)
                .style("stroke", "#f1f3f5")
                .style("stroke-dasharray", "3,3");
                
            // Horizontal grid lines
            const yTicks = yScale.ticks(10);
            gridGroup.selectAll(".grid-y")
                .data(yTicks)
                .join("line")
                .attr("class", "grid-y")
                .attr("x1", 0)
                .attr("x2", width)
                .attr("y1", d => yScale(d))
                .attr("y2", d => yScale(d))
                .style("stroke", "#f1f3f5")
                .style("stroke-dasharray", "3,3");
        }

        function drawAxes() {
            // X Axis
            const xAxis = d3.axisBottom(xScale)
                .tickFormat(d3.format("d"))
                .ticks(10);
                
            xAxisGroup
                .attr("transform", `translate(0,${height})`)
                .call(xAxis)
                .call(g => g.select(".domain").remove());
                
            // Y Axis
            const yAxis = d3.axisLeft(yScale)
                .tickFormat(d3.format("d"))
                .ticks(10);
                
            yAxisGroup
                .call(yAxis)
                .call(g => g.select(".domain").remove());
                
            // Axis labels
            g.selectAll(".axis-label").remove();
            
            g.append("text")
                .attr("class", "axis-label")
                .attr("transform", "rotate(-90)")
                .attr("y", -60)
                .attr("x", -height/2)
                .attr("text-anchor", "middle")
                .style("fill", "#6c757d")
                .style("font-size", "13px")
                .text("Birth Year");
                
            g.append("text")
                .attr("class", "axis-label")
                .attr("x", width/2)
                .attr("y", height + 45)
                .attr("text-anchor", "middle")
                .style("fill", "#6c757d")
                .style("font-size", "13px")
                .text("Activity Period");
        }

        function drawConnections(filteredData) {
            const connections = [];
            filteredData.forEach((d, i) => {
                if (d.death) {
                    connections.push({
                        source: d,
                        target: {...d, y: d.death},
                        id: `conn-${d.id}`
                    });
                }
            });
            
            connectionsGroup.selectAll(".connection-line")
                .data(connections, d => d.id)
                .join("line")
                .attr("class", "connection-line")
                .attr("x1", d => xScale(d.source.y))
                .attr("y1", d => yScale(d.source.birth))
                .attr("x2", d => xScale(d.target.y))
                .attr("y2", d => yScale(d.source.death || d.source.birth))
                .style("stroke", d => colorMap[d.source.type])
                .style("opacity", 0.3);
        }

        function drawPoints(filteredData) {
            const points = pointsGroup.selectAll(".data-point")
                .data(filteredData, d => d.id);
                
            points.exit()
                .transition()
                .duration(300)
                .attr("opacity", 0)
                .remove();
                
            const pointsEnter = points.enter()
                .append("g")
                .attr("class", "data-point")
                .attr("transform", d => `translate(${xScale(d.y)},${yScale(d.birth)})`)
                .attr("opacity", 0);
                
            // Add shapes based on type
            pointsEnter.each(function(d) {
                const el = d3.select(this);
                const size = 8;
                const color = colorMap[d.type];
                
                if (d.type === "private") {
                    el.append("circle")
                        .attr("r", size)
                        .attr("fill", color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2);
                } else if (d.type === "hybrid") {
                    el.append("rect")
                        .attr("x", -size)
                        .attr("y", -size)
                        .attr("width", size * 2)
                        .attr("height", size * 2)
                        .attr("rx", 2)
                        .attr("fill", color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2);
                } else {
                    // Triangle
                    const triangle = d3.symbol()
                        .type(d3.symbolTriangle)
                        .size(size * 20);
                    el.append("path")
                        .attr("d", triangle)
                        .attr("fill", color)
                        .attr("stroke", "white")
                        .attr("stroke-width", 2);
                }
            });
            
            // Merge and update
            points.merge(pointsEnter)
                .transition()
                .duration(500)
                .attr("transform", d => `translate(${xScale(d.y)},${yScale(d.birth)})`)
                .attr("opacity", 1);
                
            // Event listeners
            pointsGroup.selectAll(".data-point")
                .on("mouseover", function(event, d) {
                    d3.select(this).select("circle, rect, path")
                        .transition()
                        .duration(200)
                        .attr("transform", "scale(1.3)");
                        
                    tooltip
                        .style("opacity", 1)
                        .html(`
                            <strong>${d.name}</strong>
                            <span>Birth: ${d.birth}</span>
                            ${d.death ? `<span>Death: ${d.death}</span>` : '<span>Alive</span>'}
                            <span>Type: ${d.type.charAt(0).toUpperCase() + d.type.slice(1)}</span>
                        `)
                        .style("left", (event.pageX + 10) + "px")
                        .style("top", (event.pageY - 10) + "px");
                })
                .on("mouseout", function() {
                    d3.select(this).select("circle, rect, path")
                        .transition()
                        .duration(200)
                        .attr("transform", "scale(1)");
                    tooltip.style("opacity", 0);
                });
        }

        function updateChart() {
            const dims = updateDimensions();
            drawGrid();
            drawAxes();
            
            const activeFilter = document.querySelector('.filter-tab.active').dataset.filter;
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            
            let filteredData = data;
            
            if (activeFilter !== 'all') {
                filteredData = filteredData.filter(d => d.type === activeFilter);
            }
            
            if (searchTerm) {
                filteredData = filteredData.filter(d => 
                    d.name.toLowerCase().includes(searchTerm)
                );
            }
            
            drawConnections(filteredData);
            drawPoints(filteredData);
        }

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.5, 5])
            .extent([[0, 0], [width, height]])
            .on("zoom", (event) => {
                currentTransform = event.transform;
                const newXScale = event.transform.rescaleX(xScale);
                const newYScale = event.transform.rescaleY(yScale);
                
                xAxisGroup.call(d3.axisBottom(newXScale).tickFormat(d3.format("d")));
                yAxisGroup.call(d3.axisLeft(newYScale).tickFormat(d3.format("d")));
                
                pointsGroup.selectAll(".data-point")
                    .attr("transform", d => `translate(${newXScale(d.y)},${newYScale(d.birth)})`);
                    
                connectionsGroup.selectAll(".connection-line")
                    .attr("x1", d => newXScale(d.source.y))
                    .attr("y1", d => newYScale(d.source.birth))
                    .attr("x2", d => newXScale(d.target.y))
                    .attr("y2", d => newYScale(d.source.death || d.source.birth));
                    
                // Update grid
                gridGroup.selectAll(".grid-x")
                    .attr("x1", d => newXScale(d))
                    .attr("x2", d => newXScale(d));
                gridGroup.selectAll(".grid-y")
                    .attr("y1", d => newYScale(d))
                    .attr("y2", d => newYScale(d));
            });

        svg.call(zoom);

        // Event listeners
        document.querySelectorAll('.filter-tab').forEach(tab => {
            tab.addEventListener('click', (e) => {
                document.querySelectorAll('.filter-tab').forEach(t => t.classList.remove('active'));
                e.target.classList.add('active');
                updateChart();
            });
        });

        document.getElementById('searchInput').addEventListener('input', updateChart);

        document.querySelectorAll('.time-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.time-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                const year = parseInt(e.target.dataset.year);
                // Smooth transition to that time period
                const targetX = xScale(year);
                svg.transition()
                    .duration(750)
                    .call(zoom.transform, d3.zoomIdentity.translate(width/2 - targetX, 0).scale(1));
            });
        });

        document.getElementById('zoomIn').addEventListener('click', () => {
            svg.transition().duration(300).call(zoom.scaleBy, 1.3);
        });

        document.getElementById('zoomOut').addEventListener('click', () => {
            svg.transition().duration(300).call(zoom.scaleBy, 0.7);
        });

        document.getElementById('resetZoom').addEventListener('click', () => {
            svg.transition().duration(500).call(zoom.transform, d3.zoomIdentity);
        });

        document.getElementById('fullscreen').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        });

        document.getElementById('help').addEventListener('click', () => {
            alert("Navigation:\n‚Ä¢ Scroll to zoom\n‚Ä¢ Drag to pan\n‚Ä¢ Click points for details\n‚Ä¢ Use filters to categorize\n‚Ä¢ Search by name");
        });

        // Legend interaction
        document.querySelectorAll('.legend-item').forEach(item => {
            item.addEventListener('click', () => {
                const type = item.dataset.type;
                document.querySelectorAll('.filter-tab').forEach(t => {
                    if (t.dataset.filter === type) {
                        t.click();
                    }
                });
            });
        });

        // Minimap interaction
        let isDragging = false;
        const minimapBrush = document.getElementById('minimapBrush');
        
        minimapBrush.addEventListener('mousedown', (e) => {
            isDragging = true;
            e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const minimap = document.getElementById('minimap');
            const rect = minimap.getBoundingClientRect();
            let newTop = e.clientY - rect.top - minimapBrush.offsetHeight/2;
            newTop = Math.max(0, Math.min(newTop, rect.height - minimapBrush.offsetHeight));
            minimapBrush.style.top = newTop + 'px';
            
            // Update chart view based on minimap position
            const ratio = newTop / (rect.height - minimapBrush.offsetHeight);
            const yearRange = 2025 - 1800;
            const targetYear = 1800 + (yearRange * ratio);
            const targetY = yScale(targetYear);
            svg.call(zoom.transform, d3.zoomIdentity.translate(0, -targetY + height/2));
        });
        
        document.addEventListener('mouseup', () => {
            isDragging = false;
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            updateChart();
        });

        // Initialize
        updateChart();
        
        // Draw minimap preview
        const minimapSvg = d3.select("#minimap")
            .append("svg")
            .attr("width", "100%")
            .attr("height", "100%");
            
        const minimapY = d3.scaleLinear()
            .domain([1800, 2025])
            .range([0, 200]);
            
        const minimapX = d3.scaleLinear()
            .domain([1750, 2030])
            .range([0, 50]);
            
        minimapSvg.selectAll("circle")
            .data(data)
            .enter()
            .append("circle")
            .attr("cx", d => minimapX(d.y))
            .attr("cy", d => minimapY(d.birth))
            .attr("r", 1.5)
            .attr("fill", d => colorMap[d.type])
            .attr("opacity", 0.6);
    </script>
</body>
</html>